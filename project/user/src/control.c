#include "control.h"
#include "imu660ra.h"
#include "zf_common_headfile.h"
#define Row   180 //148
#define Col   180
float Vx, Vy, Vz;//Vx?????x????????Vy?????y????????Vz?????????????????????
float target_motor[4];//???????????pwm?
float Car_H = 0.8;//????????
float Car_W = 0.6;//???????????��???m,?????????
float Velocity_KP = 0; //???PID
float Velocity_KI = 0.1; //???PID???????????????????????????????��
float turn_angle;//?????????
int spin;//??????????????
int translation=0;//???????????????????????????
int encoder[4];//???????????
int pid_motor[4];//???pid?????????
int midline[Row];//???????????
float Keep_Bias;//??????????
pid_info LF_motor_pid;//???pid
pid_info RF_motor_pid;
pid_info LB_motor_pid;
pid_info RB_motor_pid;

pid_info Speed[4];//?????????��0???????1?????2???????3?????

/**
 * @brief ??????????????
 * @param ??
 * @return ??
 */
void Motor_Init(void)
{
  gpio_init(DIR_LF, GPO, GPIO_HIGH, GPO_PUSH_PULL); //???
  gpio_init(DIR_LB, GPO, GPIO_HIGH, GPO_PUSH_PULL); //???
  gpio_init(DIR_RF, GPO, GPIO_HIGH, GPO_PUSH_PULL); //???
  gpio_init(DIR_RB, GPO, GPIO_HIGH, GPO_PUSH_PULL); //???

  pwm_init(motor_LF, 15000, 1200); //???pwm
  pwm_init(motor_LB, 15000, 1200); //???pwm
  pwm_init(motor_RF, 15000, 1200); //???pwm
  pwm_init(motor_RB, 15000, 1200); //???pwm
}


/**
 * @brief 编码器初始化函数
 * @param 无
 * @return 无?
 */
void Encoder_Init(void)
{
  encoder_dir_init(ENCODER_LF, ENCODER_LF_LSB, ENCODER_LF_DIR); // 初始化编码器模块与引脚 方向编码器模式
  encoder_dir_init(ENCODER_LB, ENCODER_LB_LSB, ENCODER_LB_DIR); // 初始化编码器模块与引脚 方向编码器模式
  encoder_dir_init(ENCODER_RF, ENCODER_RF_LSB, ENCODER_RF_DIR); // 初始化编码器模块与引脚 方向编码器模式
  encoder_dir_init(ENCODER_RB, ENCODER_RB_LSB, ENCODER_RB_DIR); // 初始化编码器模块与引脚 方向编码器模式
}

/**
 * @brief 读取编码器示数
 * @param 无
 * @return 无
 */
void Read_Encoder(void)
{
  //读取编码器计数值
  encoder[0] = -encoder_get_count(ENCODER_LF);//????????????
  encoder[1] = encoder_get_count(ENCODER_LB);
  encoder[2] = encoder_get_count(ENCODER_RF);
  encoder[3] = encoder_get_count(ENCODER_RB);

  //计算对应轮子的速度
  for(uint8 i=0;i<4;i++)
  {
    Speed[i].now_speed = (encoder[i] * 0.2636719*PI); // 0.2637????????????��?????????????
  }
// 清空编码器计数
  encoder_clear_count(ENCODER_LF);
  encoder_clear_count(ENCODER_LB);
  encoder_clear_count(ENCODER_RF);
  encoder_clear_count(ENCODER_RB);
}

/**
 * @brief ????????????1.0?��???????????
 * @param 
 * @return ??
 */
void Car_Inverse_kinematics_solution(float target_Vx, float target_Vy, float target_Vz) //
{
  Speed[0].target_speed = -(+target_Vx + target_Vy + target_Vz); //??????
  Speed[1].target_speed = -(-target_Vx + target_Vy + target_Vz); //??????
  Speed[2].target_speed = -(-target_Vx + target_Vy - target_Vz); //??????
  Speed[3].target_speed = -(+target_Vx + target_Vy - target_Vz); //??????
}

/**
 * @brief ????????????2.0?????1.0????Vz?????????????
 * @param ??
 * @return ??
 * @attention // ????????????????????  x:?+??-  y:??+??-  z:??+?-
 */
void Move_Transfrom(float target_Vx, float target_Vy, float target_Vz)
{
  Speed[0].target_speed = target_Vx + target_Vy - target_Vz * (Car_H/2 + Car_W/2);
  target_motor[1] = -target_Vx + target_Vy - target_Vz * (Car_H/2 + Car_W/2);
  target_motor[2] = -target_Vx + target_Vy + target_Vz * (Car_H/2 + Car_W/2);
  target_motor[3] = target_Vx + target_Vy + target_Vz * (Car_H/2 + Car_W/2); //???????????��?????????
}
         
/**
 * @brief Pid?????????(????????????????0)
 * @param ??
 * @return ??
 */
void PidInit(void)
{
  for(uint8 i=0;i<4;i++)
  {
    Speed[i].target_speed = 1.00;
    Speed[i].kd= 0.00;
    Speed[i].ki        = 0.00;
    Speed[i].kd        = 0.00;
    Speed[i].error     = 0.00;
    Speed[i].lastError = 0.00;
    Speed[i].dError    = 0.00;
    Speed[i].output    = 0.00;
    Speed[i].output_last   = 0.00;
  }
  //?????PI???
  Speed[0].kp=10;
	Speed[0].ki=1;
	//?????PI???
	Speed[1].kp=20;
	Speed[1].ki=2;
	//?????PI???
	Speed[2].kp=60;
	Speed[2].ki=2;
	//?????PI???
	Speed[3].kp=10;
	Speed[3].ki=1;//????????pi???

}

/**
 * @brief ?????pid???
 * @param pid_info *pid ????????????????float target_speed ??????
 * @return ???????????????
 */
void increment_pid(void)
{
  static float PID_Bias[4], PID_Last_bias[4];

  PID_Bias[0] = target_motor[0] - encoder[0]; //当前偏差值
  PID_Bias[1] = target_motor[1] - encoder[1]; //当前偏差值
  PID_Bias[2] = target_motor[2] - encoder[2]; //当前偏差值
  PID_Bias[3] = target_motor[3] - encoder[3]; //当前偏差值

  pid_motor[0] += Velocity_KP * (PID_Bias[0] - PID_Last_bias[0]) + Velocity_KI * PID_Bias[0]; //增量式PI控制器
  pid_motor[1] += Velocity_KP * (PID_Bias[1] - PID_Last_bias[1]) + Velocity_KI * PID_Bias[1]; //增量式PI控制器
  pid_motor[2] += Velocity_KP * (PID_Bias[2] - PID_Last_bias[2]) + Velocity_KI * PID_Bias[2]; //增量式PI控制器
  pid_motor[3] += Velocity_KP * (PID_Bias[3] - PID_Last_bias[3]) + Velocity_KI * PID_Bias[3]; //增量式PI控制器

  PID_Last_bias[0] = PID_Bias[0]; //更新上一次偏差
  PID_Last_bias[1] = PID_Bias[1]; //更新上一次偏差
  PID_Last_bias[2] = PID_Bias[2]; //更新上一次偏差
  PID_Last_bias[3] = PID_Bias[3]; //更新上一次偏差
	
}

/**
 * @brief ?????pid???????
 * @param ??
 * @return ??
 */
void PID_cale()
{
	increment_pid();
}


/**
 * @brief ??????????????
 * @param ??
 * @return ??
 * @attention ????????PID_motor[i]??????PID?????pwm???
 */
void motor_close_control(void)
{
  int j;
  for (j = 0; j < 4; j++) //???
  {
    if (pid_motor[j] > AMPLITUDE_MOTOR)
      pid_motor[j] = AMPLITUDE_MOTOR;
    if (pid_motor[j] < -AMPLITUDE_MOTOR)
      pid_motor[j] = -AMPLITUDE_MOTOR;
  }
  if (pid_motor[0] > 0) //???1   ??? ????????? ???? (1000/TIMER1_PWM_DUTY_MAX*100)
  {
    gpio_set_level(DIR_LF, 0);                 // DIR???????
    pwm_set_duty(motor_LF, (int)pid_motor[0]); // ????????
  }
  else //???1   ???
  {
    gpio_set_level(DIR_LF, 1);
    pwm_set_duty(motor_LF, (int)-pid_motor[0]);
  }

  if (pid_motor[1] > 0) //???2   ???
  {
    gpio_set_level(DIR_LB, 0);
    pwm_set_duty(motor_LB, (int)pid_motor[1]);
  }
  else //???2   ???
  {
    gpio_set_level(DIR_LB, 1);
    pwm_set_duty(motor_LB, (int)-pid_motor[1]);
  }

  if (pid_motor[2] > 0) //???3   ???
  {
    gpio_set_level(DIR_RF, 1);
    pwm_set_duty(motor_RF, (int)pid_motor[2]);
  }
  else //???3   ???
  {
    gpio_set_level(DIR_RF, 0);//????????????????????DIR??????????
    pwm_set_duty(motor_RF, (int)-pid_motor[2]);
  }

  if (pid_motor[3] > 0) //???4   ???
  {
    gpio_set_level(DIR_RB, 1);
    pwm_set_duty(motor_RB, (int)pid_motor[3]);
  }
  else //???4   ???
  {
    gpio_set_level(DIR_RB, 0);
    pwm_set_duty(motor_RB, (int)-pid_motor[3]);
  }
}
/**
 * @brief ???????????????
 * @param ??
 * @return ??
 * @attention ????????target_motor[i]?????????????????pwm???
 */
void motor_control(void)
{
  for (int j= 0; j < 4; j++) //???
  {
    if (pid_motor[j] > AMPLITUDE_MOTOR)
      pid_motor[j] = AMPLITUDE_MOTOR;
    if (pid_motor[j] < -AMPLITUDE_MOTOR)
      pid_motor[j] = -AMPLITUDE_MOTOR;
  }
  if (pid_motor[0] > 0) //???1   ??? ????????? ???? (1000/TIMER1_PWM_DUTY_MAX*100)
  {
    gpio_set_level(DIR_LF, 0);                 // DIR???????
    pwm_set_duty(motor_LF, (int)pid_motor[0]); // ????????
  }
  else //???1   ???
  {
    gpio_set_level(DIR_LF, 1);
    pwm_set_duty(motor_LF, (int)-pid_motor[0]);
  }

  if (pid_motor[1] > 0) //???2   ???
  {
    gpio_set_level(DIR_LB, 0);
    pwm_set_duty(motor_LB, (int)pid_motor[1]);
  }
  else //???2   ???
  {
    gpio_set_level(DIR_LB, 1);
    pwm_set_duty(motor_LB, (int)-pid_motor[1]);
  }

  if (pid_motor[2] > 0) //???3   ???
  {
    gpio_set_level(DIR_RF, 1);
    pwm_set_duty(motor_RF, (int)pid_motor[2]);
  }
  else //???3   ???
  {
    gpio_set_level(DIR_RF, 0);
    pwm_set_duty(motor_RF, (int)-pid_motor[2]);
  }

  if (pid_motor[3] > 0) //???4   ???
  {
    gpio_set_level(DIR_RB, 1);
    pwm_set_duty(motor_RB, (int)pid_motor[3]);
  }
  else //???4   ???
  {
    gpio_set_level(DIR_RB, 0);
    pwm_set_duty(motor_RB, (int)-pid_motor[3]);
  }
}

/**
 * @brief ?????????
 * @param ??
 * @return ??
 * @attention ????????PID_motor[i]??????PID?????pwm???
 */
void Speed_Control(float Vx_Speed, float Vy_Speed, float Vz_Speed)
{
// 	  Car_Inverse_kinematics_solution(Vx_Speed, Vy_Speed, Vz_Speed);
    Move_Transfrom(Vx_Speed, Vy_Speed, Vz_Speed);//???????
//     motor_control();
    Car_Inverse_kinematics_solution(Vx_Speed, Vy_Speed, Vz_Speed);
    // motor_close_control();//??????????
}
//-------------------------------------------------------------------------------------------------------------------
//  @brief      ?????????????????????
//  @param      mode (1?????????2????)??value????????????????????????????turn_speed???????(target_Vx)
//  @return     void
//  @since      v1.0
//  Sample usage: value????????????????????????????turn_speed???????
//-------------------------------------------------------------------------------------------------------------------
void move(int8 mode,float value,int16 stra_speed,int16 turn_speed)
{
  int k = 0;
  translation=midline[Row-1]-Col/2; //?????????��?????????
  for(k = Row; k < 65; k--)
  {
     spin=spin+midline[k];//?????????????????????
     spin=spin/(Row-k)-Col/2;//???????????????????????
  }
}

/**
 * @brief 18?????????????????,?????????????��?????????��m/s
 * @param ??
 * @return ??
 * @attention ???????????????? = (???????? / ??????????)  * ?????????? / ??????? ) * ????? / ?????????
 */
void Encoder_odometer(void)
{
  static float Angle_Bias = 0;//??????
  static float V_enco[4] = {0}, Vx_enco = 0, Vy_enco = 0;

  // Angle_Bias = (90 - Angle_Z) * PI / 180;//????????????????????

/****??????????******/
  // V_enco[0] = 0.2636719 * PI * (float)encoder[0]; // 0.2637????????????��
  // V_enco[1] = 0.2636719 * PI * (float)encoder[1];
  // V_enco[2] = 0.2636719 * PI * (float)encoder[2];
  // V_enco[3] = 0.2636719 * PI * (float)encoder[3];
 //???????????????��???
 //    Vx_enco=(V_enco[0]-V_enco[1]-V_enco[2]+V_enco[3])/4;//???????
 //    Vy_enco=(V_enco[0]+V_enco[1]+V_enco[2]+V_enco[3])/4;//??????
//  Vx_enco = -(V_enco[0] - V_enco[1] - V_enco[2] + V_enco[3]) / 4; //???????????????????????
//  Vy_enco = -(V_enco[0] + V_enco[1] + V_enco[2] + V_enco[3]) / 4; //??????
 //    Car_dis_x+=Vx_enco*0.01;
 //    Car_dis_y+=Vy_enco*0.01;

// #if 1
//  if (Angle_Bias >= 0)
//  {
//    Vx_1 = Vx_enco * sin(Angle_Bias);
//    Vx_2 = Vx_enco * cos(Angle_Bias);
//    Vy_1 = Vy_enco * cos(Angle_Bias);
//    Vy_2 = Vy_enco * sin(Angle_Bias); //?????????????
//    Vx_world = Vx_2 - Vy_2;
//    Vy_world = Vx_1 + Vy_1;
//  }
//  if (Angle_Bias < 0)
//  {
//    Angle_Bias = -Angle_Bias;
//    Vx_1 = Vx_enco * sin(Angle_Bias);
//    Vx_2 = Vx_enco * cos(Angle_Bias);
//    Vy_1 = Vy_enco * cos(Angle_Bias);
//    Vy_2 = Vy_enco * sin(Angle_Bias); //?????????????
//    Vx_world = Vx_2 + Vy_2;
//    Vy_world = -Vx_1 + Vy_1;
//  }
// #endif
//  Car_dis_x += Vx_world * 0.01;
//  Car_dis_y += Vy_world * 0.01;

//  Car_dis_x2 += Vx_world * 0.01;
//  Car_dis_y2 += Vy_world * 0.01;
}
